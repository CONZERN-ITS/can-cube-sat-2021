#ifndef I2C_INC_H_
#define I2C_INC_H_

#include <stddef.h>

#include "its-i2c-link-conf.h"


//! Статистика i2c-линка
typedef struct its_i2c_link_stats_t
{
	// Статистика по получению данных
	// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

	//! Количество раз, когда мы начинали принимать пакет
	uint16_t rx_packet_start_cnt;
	//! Количество раз, когда мы закончили принимать пакет
	uint16_t rx_packet_done_cnt;
	//! Количество раз, когда мы начинали получение команды
	uint16_t rx_cmds_start_cnt;
	//! Количество раз, когда мы закончили получение команды
	uint16_t rx_cmds_done_cnt;
	//! Количество раз, когда мы начинали выбрасывать принимаемые байты
	uint16_t rx_drops_start_cnt;
	//! Количество раз, когда мы это делать заканчивали
	uint16_t rx_drops_done_cnt;

	// Статистика по передаче данных
	// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
	//! Сколько раз мы начинали передавать размер пакета
	uint16_t tx_psize_start_cnt;
	//! Сколько раз мы заканчивали передавать размер пакета
	uint16_t tx_psize_done_cnt;
	//! Сколько раз мы начинали передавать пакет
	uint16_t tx_packet_start_cnt;
	//! Сколько раз мы заканчивали передават пакет
	uint16_t tx_packet_done_cnt;
	//! Сколько раз мы начинали гнать нули вместо пакета
	uint16_t tx_zeroes_start_cnt;
	//! Сколько раз мы заканчивали гнать нули
	uint16_t tx_zeroes_done_cnt;
	//! Сколько раз у нас попросили пакет, а его не было
	uint16_t tx_empty_buffer_cnt;
	//! Сколько раз внутренний клиент пытался отправить пакет, а места под него не было
	uint16_t tx_overruns_cnt;

	// Статистика по командам
	// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

	//! Сколько раз у нас просили размер пакета
	uint16_t cmds_get_size_cnt;
	//! Сколько раз у нас просили пакет
	uint16_t cmds_get_packet_cnt;
	//! Сколько раз у нас просили забрать пакет
	uint16_t cmds_set_packet_cnt;
	//! Сколько раз мы получали чуш вместо команды
	uint16_t cmds_invalid_cnt;

	// Системная статистика
	// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

	//! Количетво рестартов i2c перефирии из-за ошибок на шине
	uint16_t restarts_cnt;
	//! Количество BERR ошибок
	uint16_t berr_cnt;
	//! Количество ARLO ошибок
	uint16_t arlo_cnt;
	//! Количество OVF ошибок
	uint16_t ovf_cnt;
	//! Количество AF ошибок
	uint16_t af_cnt;
	//! Количество зажиганий BTF (остановки/незапуска ДМА по-сути)
	uint16_t btf_cnt;
	//! Количество случаев, когда хост запросил не столько данных, сколько должен был
	//! (насколько мы можем судить по счетчикам DMA
	uint16_t tx_wrong_size_cnt;
	//! Количество случаев, когда хост передал нам не столько данных, сколько мы ожидали
	//! (насколько мы можем судить по счетчикам DMA
	uint16_t rx_wrong_size_cnt;

} its_i2c_link_stats_t;


//! Запуск модуля
/*! Нужно вызывать лишь однажды */
int its_i2c_link_start(void);

//! Сброс модуля и переиницилизация
/*! В идеале вызывать не нужно, все работает автоматически.
 *  Но если обмена слишком долго нет, то имеет смысле дернуть.
 *  Не как альтернатива вотчдогу, но как его упреждение */
int its_i2c_link_reset(void);

//! Отправка пакета мастеру на шине
/*! У модуля есть несколько буферов для TX, в которые он складывает данные
 *  и затем отдает мастеру на шине по мере запроса.
 *  Если буфера кончились - функция вернет -EAGAIN */
int its_i2c_link_write(const void * data, size_t data_size);

//! Получение пакета от мастера.
/*! Так же, как и write - работает не прямо в момент вызова.
 *  Пакета получаются от мастера на фоне. Если прямо сейчас пакета нет, вернет -EAGAIN */
int its_i2c_link_read(void * buffer, size_t buffer_size);

//! Получение статистики модуля
void its_i2c_link_stats(its_i2c_link_stats_t * statsbuf);

//! Обработчик EVENT прерываний на целевой I2C шине
void its_i2c_link_it_event_handler(void);

//! Обработчик ERROR прерываний на целевой I2C шине
void its_i2c_link_it_error_handler(void);


#endif /* I2C_INC_H_ */
