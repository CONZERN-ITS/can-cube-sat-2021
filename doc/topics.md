# Шина сообщений GCS

Шина наземной станции построена на ZMQ. Каждый абонент шины имеет два сокета - один PUB, другой SUB. Реквизты для соединений сокетов передаются через переменные окружения ITS_GBUS_PUB_ENDPOINT и ITS_GBUS_SUB_ENDPOINT. Все приложения вызывают `zmq_connect(...)` для этих эндпиоинтах на своих сокетах.

Все сообщения состоят минимум из двух частей (zmq multipart). Первая часть - это просто строка, которая показывает топик сообщения на шине. Дальше идет одна или несколько частей собственно сообщения.

В метаданных всех сообщений хранится время его формирования в стандартном формате time_s, time_us - целые части секунд POSIX таймштампа и дробные (микросекунды)


## Топики и сообщения

### Сообщения радио тракта

Эта группа сообщений связана непосредственно с радиоканалом. Они показывают состояние радиоканала и данные, которые по этому каналу ходят в наиболее примитивной форме.


#### radio.uplink_frame

Радио-сервер подписывается на этот топик и ожидает получать в него фреймы, которые будет отправлены по радио-каналу наверх. Не предполагается какой-либо очереди на этом топике и в аплинк пойдет самый свежий фрейм доступный на данный момент. Чтобы обеспечить управление потоком - отправителю данных следует смотреть на сообщения топика `radio.uplink_state`.

**Структура**

1. Топик;
2. Метаданные аплинк фрейма;
3. Сам аплинк фрейм.

Метаданные это JSON. Содержит одно поле - целое число, которое уникально идентифицирует передаваемый фрейм. При помощи этого числа можно узнавать передаваемый фрейм в сообщение `radio.uplink_state`. Число 64 битное и значение 0 - запрещено, так как призвано обозначать отсутствие фрейма в том или ином буфере

Схема: 
```json
{
	"type": "object",
	"properties": {
		"time_s": { "type:" "integer" },
		"time_us": { "type:" "integer" },
		"cookie": {
			"type": "integer",
			"minimum": 1
		}
	}
}
```

Пример:
```json
{
	"time_s": 1624224857,
	"time_us": 428526,
	"cookie": 10
}
```

Сам фрейм это простой бинарный массив байт длины не более чем условлено в радио-тракте. Все лишние байты будут отброшены, недобор будет дополнен нулями.

**Условия генерации**

Такое сообщение формируется кем-либо, кто хочет отправить фрейм по радио-каналу когда он захочет его отправить. Предполагается, что в системе такое _существо_ должно быть одно и что это будет USLP-стек


#### radio.uplink_state

Состояние _передаточных_ буферов сервера радио и самого радио.

**Структура** 

1. Топик;
2. Состояние передаточных буферов.

Состояние передаточных буферов - это JSON, содержащий 4 поля. Каждое поле содержит номер cookie, который передаются вместе с соответствующим фреймом. Поля показывают 4 _буфера_ или _состояния_.

Первое поле - _ожидает отправки_. Это поле содержит cookie номер фрейма, который ожидает очереди для отправки по радио-каналу. Если сейчас нет фрейма ожидающего отправки - поле имеет значение `null`.

Второе поле - _отправляется_. Это поле содержит cookie номер фрейма, который сейчас отправляется. Если сейчас не отправляется никакой фрейм - поле имеет значение `null`.

Третье поле - _отправлено_. Это поле содержит cookie номер фрейма, который был успешно отправлен в эфир. Поле инициализируется значением `null`, но не очищается а лишь обновляется при передаче очередного фрейма.

Четвертое поле - _отброшено_. Это поле содержит cookie номер фрейма, который не был отправлен, а был отброшен по той или иной причине. Та же. как и поле _отправлено_ инициализуется значением `null`, но затем не очищается, а лишь обновлется.

Схема:

```json
{
	"type": "object",
	"properties": {
		"time_s": { "type:" "integer" },
		"time_us": { "type:" "integer" },
		"cookie_in_wait": {
			"type": "integer",
			"minimum": 1
		},
		"cookie_in_progress": {
			"type": "integer",
			"minimum": 1
		},
		"cookie_sent": {
			"type": "integer",
			"minimum": 1
		},
		"cookie_dropped": {
			"type": "integer",
			"minimum": 1
		}
	}
}

```

Пример:

```json
{
	"time_s": 1624224857,
	"time_us": 428526,
	"cookie_in_wait": 0,
	"cookie_in_progress": 3,
	"cookie_sent": 1,
	"cookie_dropped": 2
}

```

**Условия генерации**

Сообщение `radio.uplink_state` публикуется на шину при изменении значения какого-либо из его полей или же с определенным периодом (около секунды) в случае, если изменения не произошло. Публикует эти сообщения радио-сервер и предполагается, что в системе он такой один.


#### radio.downlink_frame

Радио-сервер бросает в этот топик сообщения с полученными по радио-каналу фреймами. 

**Структура**

1. Топик;
3. Метаданные фрейма;
2. Фрейм.

Метаданные фрейма это JSON. Содержит поле - флаг валидности контрольной суммы фрейма. Либо `true` если контрольная сумма сошлась, либо `false`, если не сошлась. Если вдруг контрольная сумма отключена и не проверяется - имеет значение `null`. Так же содержит некий cookie номер, который уникально идентифицирует этот фрейм. В этом же сообщении есть параметры качества сигнала с которым был принят этот фрейм и номер фрейма в радио канале (номер с которым его пульнул в эфир БКУ)

Схема:

```json
{
	"type": "object",
	"properties": {
		"time_s": { "type:" "integer" },
		"time_us": { "type:" "integer" },
		"checksum_valid": {
			"type": ["boolean", "null"]
		},
		"cookie": {
			"type": "integer",
			"minimum": 1
		},
		"frame_no": {
			"type": "integer",
			"minimum": 0, "maximum": 65535
		},
		"rssi_pkt": {
			"type": "integer"
		},
		"snr_pkt": {
			"type": "integer"
		},
		"rssi_signal": {
			"type": "integer"
		}
	}
}
```

Пример:
```json
{
	"time_s": 1624224857,
	"time_us": 428526,
	"checksum_valid": true,
	"cookie": 42,
	"rssi_pkt": -2,
	"snr_pkt": 7, 
	"rssi_signal": -3
}
```

Фрейм это массив байт, которые прям как пришли так и есть.

**Условия генерации**

Сообщение с этим топиком публикуется радио-сервером, когда он успешно завершает RX операцию не по таймауту.


#### radio.rssi_instant

Это сообщение содержит текущее значение соотношения сигнал шум, которое ощущает радио в режиме RX

**Структура**

1. Топик;
2. RSSI значение.

RSSI значение передается JSON объектом, содержащим всего одно поле: `rssi`. Это мощность принимаемого сигнала (в dBm?). Строго неположительное число.

Схема:

```json
{
	"type": "object",
	"properties": {
		"time_s": { "type:" "integer" },
		"time_us": { "type:" "integer" },
		"rssi": {
			"type": "integer"
		}
	}
}
```

Пример:
```json
{
	"time_s": 1624224857,
	"time_us": 428526,
	"rssi": -1
}
```

**Условия генерации**

С некоторых маленьким (около секунды а то и меньше) периодом все время, пока радио находится в RX режиме (а оно в нем находится часто)


#### radio.rssi_packet

Это сообщение содержит комплект значений сигнал шум, которые посчитало радио во время приёма очередного фрейма.

**Структура**

Сообщение состоит из двух частей:

1. Топик;
2. Значения RSSI.

Значения RSSI передаются в виде JSONа аж с тремя полями в каждом из которых свой аттрибут показывающий качество приёма. К сожалению не очень понятно что они значат :c. Так же в этом же сообщение хранится cookie пакета, которому соответствуют эти значения.

Схема:
```json
{
	"type": "object",
	"properties": {
		"time_s": { "type:" "integer" },
		"time_us": { "type:" "integer" },
		"cookie": {
			"type": "integer",
			"minimum": 1
		},
		"rssi_pkt": {
			"type": "integer"
		},
		"snr_pkt": {
			"type": "integer"
		},
		"rssi_signal": {
			"type": "integer"
		}
	}
}
```

Пример:
```json
{
    "time_s": 1624224858,
    "time_us": 439454,
    "checksum_valid": true,
    "cookie": 28,
    "rssi_pkt": 0,
    "snr_pkt": 13,
    "rssi_signal": 0
}
```

**Условия генерации**

Вместе с получаемым пакетом.


#### radio.stats

Это сообщение со статистикой радио и его состоянием в целом.

**Структура**

Сообщение состоит из двух частей:
1. Топик
2. Собстсвенно статистика и состояние

Состяние передается в виде джсона с целой кучей полей, названия которых говорят сами за себя.

Схема:

```json
{
	"type": "object",
	"properties": {
		"time_s": { "type:" "integer" },
		"time_us": { "type:" "integer" },
		
		// Количество полученных пакетов по мнению радио
		"pkt_received": { "type": "integer", "minimum": 0, "maximum": 65535 },
		// Ошибок контрольных сумм в телах полученных пакетах по мнению радио
		"crc_errors": { "type": "integer", "minimum": 0, "maximum": 65535 },
		// Ошибок контрольных сумм заголовков пакетов по мнению радио
		"hdr_errors": { "type": "integer", "minimum": 0, "maximum": 65535 },

		// Дальше идет массив аппаратных ошибок радио
		"error_rc64k_calib": { "type": "boolean" },
		"error_rc13m_calib": { "type": "boolean" },
		"error_pll_calib": { "type": "boolean" },
		"error_adc_calib": { "type": "boolean" },
		"error_img_calib": { "type": "boolean" },
		"error_xosc_calib": { "type": "boolean" },
		"error_pll_lock": { "type": "boolean" },
		"error_pa_ramp": { "type": "boolean" },

		// Сколько циклов RX накрутил сервер
		"srv_rx_done": { "type": "integer", "minimum": 0, "maximum": 4294967295},
		// сколько пакетов выгреб из радио сервер
		"srv_rx_frames": { "type": "integer", "minimum": 0, "maximum": 4294967295},
		// Сколько пакетов отправил в небо сервер
		"srv_tx_frames": { "type": "integer", "minimum": 0, "maximum": 4294967295}
	}
}
```

Пример:
```json
{
	"pkt_received": 0,
	"crc_errors": 0,
	"hdr_errors": 0,
	"error_rc64k_calib": false,
	"error_rc13m_calib": false,
	"error_pll_calib": false,
	"error_adc_calib": false,
	"error_img_calib": false,
	"error_xosc_calib": true,
	"error_pll_lock": false,
	"error_pa_ramp": false,
	"srv_rx_done": 3,
	"srv_rx_frames": 0,
	"srv_tx_frames": 0 
}
```

**Условия генерации**

Генерируются сервером-радио периодически.


### Сообщения сервера USLP стека

Эти сообщения связаны с управлением виртуальными каналами, на которые разбит общий физический канал связи. Разбиение на каналы сделано через CCSDS USLP протокол, а виртуальные каналы в наземной станции обслуживаются специальным приложением-сервером. Для упрощения разработки - USLP каналы и их идентификаторы инкапсулированы от потребителей и генераторов данных, путешествующих по линкам и представлены в виде отдельных специализированных каналов.

В системе определено 4 канала:

1. Команды для зонда (uplink);
2. Телеметрия зонда (downlink);
3. IP пакеты (uplink);
4. IP пакета (downlink).


IP пакеты сервером стека извлекаются из кернеля и забрасываются туда же минуя ZMQ интерфейсы. Для команд и телеметрии предусмотрены отдельные топики. Чтобы не занимать красивый префикс топика `uslp.` - эти топики имеют префикс `its.`

#### its.telecommand_request

В этот топик публикуются пакеты, которые клиенты сервера-стека хотят забросить на борт. Вместе с пакетом идет идентификатор, который позволяет сопоставлять с этим пакетом различные события, которые сервер стека будет публиковать по другим топикам.

**Структура**

1. Топик;
2. Метаданные;
3. Пакет

Метаданные это (кто бы мог подумать!) JSON. И который содержит (снова, кто бы мог подумать) cookie-номер отправляемого пакета. Ноль и тут запрещен пожалуй.

Схема:
```json
{
	"type": "object",
	"properties": {
		"cookie": {
			"type": "integer",
			"minimum": 1
		}
	}
}
```

Пример:
```json
{
	"cookie": 142
}
```

Что представляет из себя сам пакет - всей этой системе до лампочки. Пакет рассматривается как массив байт и будет доставлен до борта как массив байт. Разумеется есть какой-то предел длины пакета, и мы не будем рассматривать пакеты нулевой длины. Но конкретные цифры определить сложно. Ну и да, подразумевается, что это будет Мавлинк.


#### its.telecommand_event

В этом топике публикуются сообщения о событиях, которые могут происходить с телекомандами, которые были запрошены не отправку. События бывают вот какие:

* `rejected` - команда была отклонена сервером стека (потому что у него например место кончилось в буферах или сообщение слишком большое).

* `accepted` - команда была принята сервером стека и ожидает очереди на отправку.

* `emitted` - Последний фрейм команды вышел из стека в буфер радио (еще не был излучен в эфир, но уже почти) (TBD а может быть и ушел в эфир). Такое событие может происходить несколько раз при переотправках.

* `delivered` - Получено подтверждение о борта о том, что фрейм был получен. TBD будут ли такие сообщения у нас иметь место?

* `undelivered` - Не получено подтверждения от борта о том, что фрейм был получен и стек отчаялся его отправить и сбросил.

**Структура**

1. Топик;
2. Событие.

Событие - как всегда JSON. Содержит код события и куку телекоманды к которой оно относится

Схема:

```json
{
	"type": "object",
	"properties": {
		"cookie": {
			"type": "integer",
			"minimum": 1
		},
		"event": {
			"type": "string",
			"enum": ["rejected", "accepted", "delivered", "undelivered"]
		}
	}
}
```

Пример:
```json
{
	"cookie": 55,
	"event": "accepted"
}

```

**Условия генерации**

Сообщение публикуется сервером USLP стека при наступлении какого-то события, связанного с конкретной телекомандой.



#### its.telemetry_packet

В этом топике публикуется телеметрия зонда, которая пришла на Землю по радио и прошла все круги USLP стека. Публикуются только те пакеты, корректность которого удалось проверить на канальном уровне. То есть, если это мавлинк пакет - никто в uslp стеке не станет смотреть на его контрольную сумму. Но контрольную сумму инкапсулирующих его фреймов - там посмотрят

**Структура**

1. Топик;
2. Метаданные;
3. Пакет.

Вы наверное думаете, что метаданные и тут JSON? Ошибаетесь. Тут, что очень странно - метаданных вовсе не получается. Я просто не знаю что туда можно запихать. Я бы хотел чтобы в этом топике летали огрызки пакетов со спец флажками, но остальные разработчики упираются. Поэтому здесь будет пустое ZMQ сообщение.

Сам пакет - традиционно - пачка байт. Канальному уровню не интересно что там внутри лежит


**Условия генерации**

Публикуется USLP стеком, когда он разобрал во входном потоке корректный пакет с телеметрией (корректность проверяется механизмами стека, а не самого пакета).

### Сообщения радио тракта

Эта группа сообщений связана непосредственно с управлением антенной установкой. Они показывают ориентацию антенной установки и данные о состоянии ее внутренних параметров.

#### antenna.telemetry_packet

В этом топике публикуется телеметрия антенны.

**Структура**

1. Топик;
2. Метаданные;
3. Пакет.

Метаданных пока отсутствуют и это поле зарезервировано для будущих свершений и соответствия другим пакетам шины.

Сам пакет - набор байт, содержащий пакет MavLink ITS.


**Условия генерации**

Публикуется сервером антенны с частотой, зависящей от настроек.

#### antenna.command_packet

В этот топик публикуются пакеты, содержащие разного рода команды для антенной установки.

**Структура**

1. Топик;
2. Метаданные;
3. Пакет

Метаданных пока отсутствуют и это поле зарезервировано для будущих свершений и соответствия другим пакетам шины.

Сам пакет - набор байт, содержащий пакет MavLink ITS.

